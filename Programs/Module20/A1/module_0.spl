/////////////Resource Manager
alias functionNum R1;
if (functionNum == 3) then  // acquire disk
	alias currentPID R2;
	while (1) do
		if ([DISK_STATUS_TABLE] != 1) then
			break;
		endif;
		[PROCESS_TABLE + currentPID * 16 + 4] = WAIT_DISK; 	
		multipush (R1, R2, R3);
		call MOD_5;
		multipop (R1, R2, R3);
	endwhile;
	[DISK_STATUS_TABLE] = 1;
	[DISK_STATUS_TABLE + 4] = currentPID;
	return;
endif;
if (functionNum == 6) then  // Acquire Semaphore.
	alias currentPID R2;	
	multipush (R3, R4);
	alias cnter R3;
	cnter = 0;
	while (cnter < 32) do  // finding free entry
		if ([SEMAPHORE_TABLE + (cnter * 4) + 1] == 0) then  // process count field should be 0.
			[SEMAPHORE_TABLE + (cnter * 4) + 1] = 1;
			[SEMAPHORE_TABLE + (cnter * 4)] = -1;	
			R0 = cnter;  // return the index of the free entry. Later index needs to be multiplied by 4.
			multipop (R3, R4);
			return;
			break;	 // Sanity
		endif;
		cnter = cnter + 1;
	endwhile;
	multipop (R3, R4);
	R0 = -1;
	return;
endif;
if (functionNum == 7) then  // Release Semaphore
	alias semTableIndex R2;
	alias currentPID R3;
	multipush (R4);
	if ([SEMAPHORE_TABLE + (semTableIndex * 4)] == currentPID) then
		[SEMAPHORE_TABLE + (semTableIndex * 4)] = -1;
		alias cnter R4;
		cnter = 0;
		while (cnter < 16) do
			if ([PROCESS_TABLE + cnter * 16 + 4] == WAIT_SEMAPHORE && [PROCESS_TABLE + cnter * 16 + 5] == semTableIndex) then
				[PROCESS_TABLE + cnter * 16 + 4] = READY;
				[PROCESS_TABLE + cnter * 16 + 5] = 0;	
			endif;
			cnter = cnter + 1;
		endwhile;
	endif;
	multipop (R4);
	[SEMAPHORE_TABLE + (semTableIndex * 4) + 1] = [SEMAPHORE_TABLE + (semTableIndex * 4) + 1] - 1;
	R0 = 0;
	return;
endif;
if (functionNum == 8) then  // acquire terminal
	alias currentPID R2;
	while (1) do
		if ([TERMINAL_STATUS_TABLE] != 1) then
			break;
		endif;	
		[PROCESS_TABLE + currentPID * 16 + 4] = WAIT_TERMINAL; 
		multipush (R1, R2, R3);
		call MOD_5;
		multipop (R1, R2, R3);
	endwhile;
	[TERMINAL_STATUS_TABLE] = 1;
	[TERMINAL_STATUS_TABLE + 1] = currentPID;
	return;
endif;
if (functionNum == 9) then  // release terminal
	alias currentPID R2;
	if (currentPID != [TERMINAL_STATUS_TABLE + 1]) then
		R0 = -1;
		return;
	endif;
	[TERMINAL_STATUS_TABLE] = 0;
	multipush (R1);
	R1 = 1;
	while (R1 <= 15) do
		if ([PROCESS_TABLE + R1 * 16 + 4] == WAIT_TERMINAL) then
			[PROCESS_TABLE + R1 * 16 + 4] = READY;
		endif;
		R1 = R1 + 1;
	endwhile;
	multipop (R1);
	R0 = 0;
	return;
endif;